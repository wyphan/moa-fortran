#! -*- mode: f90; -*-
#:include "common/common.fypp"
#:set IR_KINDS_TYPES = INT_KINDS_TYPES + REAL_KINDS_TYPES
!===============================================================================
! The "take" operation
! Last edited: Dec 3, 2021 (WYP)
!===============================================================================
MODULE mod_moa_take
  USE mod_prec
  USE ISO_FORTRAN_ENV, ONLY: u => error_unit

  IMPLICIT NONE

  PRIVATE
  PUBLIC :: moa_take

#:global TAKE_MAX_DIM
#:set TAKE_MAX_DIM = 15

  INTERFACE moa_take
#:for k1, t1 in INT_KINDS_TYPES
  #:for k2, t2 in IR_KINDS_TYPES

    MODULE PROCEDURE take_sv_${k1}$_${k2}$ ! ${k1}$ scalar take ${k2}$ vector
    MODULE PROCEDURE take_sr_${k1}$_${k2}$ ! ${k1}$ scalar take ${k2}$ array

#:endfor
#:endfor
  END INTERFACE moa_take

  interface check_overtake
#:for k1, t1 in INT_KINDS_TYPES
    module procedure check_overtake_${k1}$
#:endfor
  end interface check_overtake

CONTAINS

!===============================================================================
! Helper function to print error message on overtake
!===============================================================================
#:for k1, t1 in INT_KINDS_TYPES
  LOGICAL FUNCTION check_overtake_${k1}$ ( sigma, n )

    ! Input arguments
    ${t1}$, INTENT(IN) :: sigma, n

    ! Internal variables
    LOGICAL :: lvalid

    ! Initialize
    lvalid = .FALSE.

    IF( ABS(sigma) <= n ) THEN
      lvalid = .TRUE.
    ELSE
      lvalid = .FALSE.
      WRITE(u,'(A,g0,A,g0)') 'Error[moa_take]: Overtake not allowed ', &
                               sigma, ' out of ', n
    END IF

    check_overtake_${k1}$ = lvalid
  END FUNCTION check_overtake_${k1}$
#:endfor

!===============================================================================
! Helper function to print error message on scalar take scalar
!===============================================================================
  SUBROUTINE error_scalar
    IMPLICIT NONE
    WRITE(u,'(A)') 'Error[moa_take]: Cannot perform scalar take scalar'
  END SUBROUTINE error_scalar

!===============================================================================
! Implementation of scalar take vector for ${k1} scalar and ${k2} vector
!===============================================================================
#:for k1, t1 in INT_KINDS_TYPES
  #:for k2, t2 in IR_KINDS_TYPES
  FUNCTION take_sv_${k1}$_${k2}$ ( sigma, vec ) RESULT( take )

    IMPLICIT NONE

    ! Arguments
    ${t1}$, INTENT(IN) :: sigma
    ${t2}$, INTENT(IN), TARGET :: vec(:)
    ${t2}$, POINTER :: take(:)

    ! Internal variables
    ${t1}$ :: n
    LOGICAL :: lvalid

    n = SIZE( vec, 1 )
    lvalid = check_overtake( sigma, n )
    IF( lvalid ) THEN

      IF( sigma > 0 ) THEN

        ! Positive take
        take => vec( :sigma )

      ELSE

        ! Negative take
        ! Note how +1 is needed here to account for 1-based Fortran indexing
        take => vec( (n+sigma+1): )

      END IF

    ELSE

      ! Overtake
      NULLIFY(take)

    END IF

  END FUNCTION take_sv_${k1}$_${k2}$
  #:endfor
#:endfor

#:for k1, t1 in INT_KINDS_TYPES
  #:for k2, t2 in IR_KINDS_TYPES
!===============================================================================
! Implementation of scalar take vector for ${k1} scalar and ${k2} assumed-rank
!===============================================================================
  FUNCTION take_sr_${k1}$_${k2}$ ( sigma, arr ) RESULT( take )

    IMPLICIT NONE

    ! Arguments
    ${t1}$, INTENT(IN) :: sigma
    ${t2}$, INTENT(IN), TARGET :: arr(..)
    INTEGER(dl) :: shparr = SHAPE(arr)
    INTEGER(dl) :: shptake = [ABS(sigma), shparr(2:)]
    ${t2}$, POINTER :: take(shptake)

    ! Internal variables
    INTEGER :: d
    ${t1}$ :: n
    LOGICAL :: lvalid
    INTEGER(dl) :: istart(RANK(arr)), iend(RANK(arr))

    SELECT RANK(arr)
    RANK(0)

      ! Take is defined for objects of dimensionality >= 1
      CALL error_scalar
      NULLIFY(take)
      RETURN

    RANK(1)

      take(:) => take_sv_${k1}$_${k2}$(sigma,arr)
      RETURN

    RANK(*)

      take(:) => take_sv_${k1}$_${k2}$(sigma,arr)
      RETURN

#:for r in range( 2, TAKE_MAX_DIM + 1 )
    RANK(${r}$)

      n = SIZE( arr, 1 )
      lvalid = check_overtake( sigma, n )
      IF( .NOT. lvalid ) NULLIFY(take)

#:endfor
    RANK DEFAULT

      WRITE(u,'(A,I0,A)') 'Error[moa_take]: Rank ', RANK(array), &
                          ' not supported yet'

    END SELECT

    ! Main compute loop
    IF( lvalid ) THEN
      IF( sigma > 0 ) THEN

        ! Positive take
        istart = [( 1, d = 1, RANK(arr) )]
        iend = [ sigma, SHAPE(arr)(2:) ]
        take => arr(istart:iend)

      ELSE

        ! Negative take
        ! Note how +1 is needed here to account for 1-based Fortran indexing
        istart = [ n+sigma+1, ( 1, d = 2, RANK(arr) )]
        iend = [ n, SHAPE(arr)(2:) ]
        take => arr(istart:iend)

      END IF
    END IF

    RETURN
  END FUNCTION take_sr_${k1}$_${k2}$

  #:endfor
#:endfor
!===============================================================================
END MODULE mod_moa_take
